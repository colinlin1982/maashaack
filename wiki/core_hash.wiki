#summary core.hash package.

= About =

*core.hash* contains hashing utility functions.

<a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Licence Creative Commons" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/2.0/uk/88x31.png" /></a>

<g:plusone size="medium"></g:plusone>

|| *package* || *FPAPI* || *CC* || *dependencies* || *cross-platform* || *redtamarin* ||
|| `core.hash.*` || FP_10_0<br>FP_9_0 || n/a || n/a || yes || 0.3.1 ||

<br>
<br>

= Introduction =

<pre>
  A hash function is any algorithm or subroutine that maps large data sets of variable length,
  called keys, to smaller data sets of a fixed length. For example, a person's name, having a
  variable length, could be hashed to a single integer. The values returned by a hash function
  are called hash values, hash codes, hash sums, checksums or simply hashes.
</pre>

Here we provide AS3 implementations of most common hash functions.

Those have been verified and tested with their C implementation counterpart.

We focus mainly on 32 bits or less digests.


= Details =

Hashes can be used in a lot of different way, wether you want a checksum,
a CRC or just a simple hash.

From implementing a !HashMap, or build a cache of files, we thought
those functions were a good candidate to insert in a *core* package.

Every implementations have the same strategy
  * we take a !ByteArray as an input<br>so you can hash strings, binaries etc.
  * we apply the algorithm on each byte

We don't do that
{{{
function hash( value:String ):uint
{
    var len:uint = value.length;
    var i:uint;
    var c:uint;

    for( i = 0; i < len; i++ )
    {
        c = value.charCodeAt( i );
        //...
    }
    //...
}
}}}
  * limited to strings
  * does not make sens to use `charCodeAt` on a binary

Instead we're doing this
{{{
function hash( bytes:ByteArray ):uint
{
    var len:uint = bytes.length;
    bytes.position = 0
    var i:uint;
    var c:uint;

    for( i = 0; i < len; i++ )
    {
        c = bytes[ i ];
        //...
    }
    //...
}
}}}
  * everything is considered as a serie of bytes
  * we hash each byte
  * allows to hash anything: strings, AMF packet, !ByteArrays, files, etc.

Some implementations can provide a `seed` parameter<br>
see [http://code.google.com/p/maashaack/source/browse/packages/core/trunk/src/core/hash/bkdr.as#51 BKDR implementation].

We will not deal with cryptographic hash function in this package<br>
because those can generate digests of 128 bits or more and require<br>
implementing special classes like !BigInteger, !BigNumber, etc.

Using redtamarin we will provide one executable that can use any hash functions
{{{
$ ./hash -u elf myfile.bin
18131988

$ ./hash -u elf -h myfile.bin
0x0114ac14
}}}
TODO

----
= Documentation =

== List of algorithms ==

Cyclic redundancy checks
|| *name* || *digest size* || *endianness* || *names, aliases* ||
|| crc8 || 8bits || big || CRC-8 ||
|| crc8_itu || 8bits || big || CRC-8/ITU ||
|| crc8_atm || 8bits || big || CRC-8/ATM ||
|| crc8_ccitt || 8bits || big || CRC-8/CCITT ||
|| crc8_maxim || 8bits || little || CRC-8/MAXIM, DOW-CRC ||
|| crc8_icode || 8bits || big || CRC-8/I-CODE ||
|| crc8_j1850 || 8bits || big || CRC-8/J1850 ||
|| crc8_wcdma || 8bits || little || CRC-8/WCDMA ||
|| crc8_rohc || 8bits || little || CRC-8/ROHC ||
|| crc8_darc || 8bits || little || CRC-8/DARC ||
|| crc16 || 16bits || little || CRC-16, ARC, CRC-IBM, CRC-16/ARC, CRC-16/LHA ||
|| crc16_buypass || 16bits || big || CRC-16/BUYPASS, CRC-16/VERIFONE ||
|| crc16_dds10 || 16bits || big || CRC-16/DDS-110 ||
|| crc16_en13757 || 16bits || big || CRC-16/EN-13757 ||
|| crc16_teledisk || 16bits || big || CRC-16/TELEDISK ||
|| modbus || 16bits || little || MODBUS ||
|| crc16_maxim || 16bits || little || CRC-16/MAXIM ||
|| crc16_usb || 16bits || little || CRC-16/USB ||
|| crc16_t10dif || 16bits || big || CRC-16/T10-DIF ||
|| crc16_dect_x || 16bits || big || CRC-16/DECT-X, X-CRC-16 ||
|| crc16_dect_r || 16bits || big || CRC-16/DECT-R, R-CRC-16 ||
|| crc16_dnp || 16bits || little || CRC-16/DNP ||
|| xmodem || 16bits || big || XMODEM, ZMODEM, CRC-16/ACORN ||
|| crc16_ccitt_false || 16bits || big || CRC-16/CCITT-FALSE, CRC-16/CCITT-FFFF ||
|| crc16_aug_ccitt || 16bits || big || CRC-16/AUG-CCITT, CRC-16/SPI-FUJITSU ||
|| crc16_genibus || 16bits || big || CRC-16/GENIBUS, CRC-16/EPC, CRC-16/I-CODE, CRC-16/DARC ||
|| kermit || 16bits || little || KERMIT, CRC-16/CCITT, CRC-16/CCITT-TRUE, CRC-CCITT ||
|| x25 || 16bits || little || X-25, CRC-16/IBM-SDLC, CRC-16/ISO-HDLC, CRC-B ||
|| crc16_mcrf4xx || 16bits || little || CRC-16/MCRF4XX ||
|| crc16_riello || 16bits || little || CRC-16/RIELLO ||
||  || 32bits || little ||  ||
||  ||  || || ||
||  ||  || || ||

*notes:*
 * we implemented only 8, 16 and 32bits<br>we discarded 4, 24, etc. or any CRC generating more than 32bits.
 * big endian means Msbit-first (Most significant bit first)
 * little endian means Lsbit-first (Least significant bit first)
 * see [http://en.wikipedia.org/wiki/Computation_of_CRC#Bit_ordering_.28Endianness.29 Computation of CRC - Bit ordering - Endianness]

<br>

Checksums (TODO, ex: MD2, MD4, MD5, SHA-1, SHA-256, etc.)
|| *name* || *digest size* || *description* ||
||  ||  || ||

<br>

Non-cryptographic hash functions
|| *name* || *digest size* || *description* ||
|| ap || 32bits || Arash Partow hash function ||
|| bkdr || 32bits || Brian Kernighan and Dennis Ritchie hash function ||
|| brp || 32bits || Bruno R. Preiss hash function ||
|| dek || 32bits || Donald E. Knuth hash function ||
|| djb || 32bits || Professor Daniel J. Bernstein hash function ||
|| elf || 32bits || ELF hash function ||
|| fnv || 32bits || Fowler–Noll–Vo hash function ||
|| js || 32bits || Justin Sobel hash function ||
|| pjw || 32bits || Peter J. Weinberger hash function ||
|| rs || 32bits || Robert Sedgwicks hash function ||
|| sdbm || 32bits || open source SDBM project hash function ||

== Ressources ==
  * [http://en.wikipedia.org/wiki/Hash_function Hash function] (Wikipedia)
  * [http://en.wikipedia.org/wiki/Checksum Checksums] (Wikipedia)
  * [http://en.wikipedia.org/wiki/Cyclic_redundancy_check Cyclic redundancy check] (Wikipedia)
  * [http://en.wikipedia.org/wiki/List_of_hash_functions List of hash functions] (Wikipedia)
  * [http://www.partow.net/programming/hashfunctions/index.html General Purpose Hash Function Algorithms] (Arash Partow)
  * [http://home.comcast.net/~bretm/hash/ Pluto Scarab — Hash Functions] (Bret Mulvey) (note: very good explanation of hash functions)
  * [http://reveng.sourceforge.net/crc-catalogue/ Catalogue of parametrised CRC algorithms] (!SourceForge)
  * [http://code.google.com/p/classless-hasher/wiki/ProvidedAlgorithms classless-hasher provided algorithms] (Google Code)

== TODO ==
  * implement Checksum functions
  * build the command line utilities

----

= Usages =

== Hashing strings ==

Simply writes UTF-8 into a bytearray and hash it
{{{
import core.hash.elf;
import core.strings.padLeft;

import flash.utils.ByteArray;

var bytes:ByteArray = new ByteArray();
      bytes.writeUTFBytes( "hello world" );

var hash:uint = elf( bytes );

trace( "ELF hash = " + hash ); //18131988
trace( "hex = " + hash.toString( 16 ) ); //hex = 114ac14
trace( "32bits hex = 0x" + padLeft( hash.toString( 16 ), 8, "0" ) ); //32bits hex = 0x0114ac14
}}}

<br>

== Hashing non-ASCII strings ==

If you need to hash non-ASCII strings you should pay attention with the difference
between Unicode and UTF-8.

When converting non-ASCII to Unicode you will end up with 2 bytes<br>
for ex: *ざ* gives in Unicode `0x3056`

When converting non-ASCII to UTF-8 you will end up with variable bytes length<br>
for ex: *ざ* gives in UTF-8 `0xE38196` (3 bytes)

The same string "ざづぜげ" will not generate the same hash, see bellow.

{{{
//UTF-8
var bytes1:ByteArray = new ByteArray();
      bytes1.writeMultiByte( "ざづぜげ", "UTF-8" );

var hash1:uint = elf( bytes );

trace( "ELF hash = " + hash1 ); //218292322
trace( "32bits hex = 0x" + padLeft( hash1.toString( 16 ), 8, "0" ) ); //32bits hex = 0x0d02e062

//Unicode
var bytes2:ByteArray = new ByteArray();
      bytes2.writeMultiByte( "ざづぜげ", "unicodeFFFE" );

var hash2:uint = elf( bytes );

trace( "ELF hash = " + hash2 ); //157834242
trace( "32bits hex = 0x" + padLeft( hash2.toString( 16 ), 8, "0" ) ); //32bits hex = 0x09685c02
}}}

Also<br>
`bytes.writeUTFBytes( "ざづぜげ" );`<br>
is the same as<br>
`bytes.writeMultiByte( "ざづぜげ", "UTF-8" );`

<br>

== Hashing binaries, bytes, files ==

Here an example using *File* and *!FileStream* in AIR
{{{
var bytes:ByteArray = new ByteArray();

var file:File = File.desktopDirectory.resolvePath( "archive.zip" );
var stream:FileStream = new FileStream();
     stream.open( file, FileMode.READ );
     stream.readBytes( bytes );
     stream.close();

var hash:uint = elf( bytes );

trace( "ELF hash = " + hash );
trace( "32bits hex = 0x" + padLeft( hash.toString( 16 ), 8, "0" ) );
}}}
<br>